/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/opus-media-recorder@0.8.0/OpusMediaRecorder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const{EventTarget:EventTarget,defineEventAttribute:defineEventAttribute}=require("event-target-shim"),{detect:detect}=require("detect-browser"),browser=detect(),AudioContext=global.AudioContext||global.webkitAudioContext,BUFFER_SIZE=4096;class OpusMediaRecorder extends EventTarget{constructor(e,t={},s={}){const{mimeType:r,audioBitsPerSecond:o,videoBitsPerSecond:a,bitsPerSecond:i}=t,{encoderWorkerFactory:n,OggOpusEncoderWasmPath:c,WebMOpusEncoderWasmPath:h}=s;if(super(),this._stream=e,this._state="inactive",this._mimeType=r||"",this._audioBitsPerSecond=o||i,this.workerState="inactive",!OpusMediaRecorder.isTypeSupported(this._mimeType))throw new TypeError("invalid arguments, a MIME Type is not supported");switch(OpusMediaRecorder._parseType(this._mimeType).subtype){case"wave":case"wav":this._mimeType="audio/wave";break;case"webm":this._mimeType="audio/webm";break;case"ogg":this._mimeType="audio/ogg";break;default:switch(browser&&browser.name){case"chrome":case"edge":default:this._mimeType="audio/webm";break;case"firefox":this._mimeType="audio/ogg";break;case"ios":case"safari":this._mimeType="audio/wave"}}switch(this._mimeType){case"audio/wave":this._wasmPath="";break;case"audio/webm":this._wasmPath=h||"";break;case"audio/ogg":this._wasmPath=c||"";break;default:throw new Error(`Internal Error: Unexpected MIME Type: ${this._mimeType}`)}let d="";document.currentScript?d=document.currentScript.src:self.location&&(d=self.location.href),d=d.substr(0,d.lastIndexOf("/"))+"/encoderWorker.umd.js","function"==typeof OpusMediaRecorder.encoderWorker&&(d=URL.createObjectURL(new Blob([`(${OpusMediaRecorder.encoderWorker})()`]))),this._workerFactory="function"==typeof n?n:e=>new Worker(d),this._spawnWorker()}get stream(){return this._stream}get mimeType(){return this._mimeType}get state(){return this._state}get videoBitsPerSecond(){}get audioBitsPerSecond(){return this._audioBitsPerSecond}_spawnWorker(){this.worker=this._workerFactory(),this.worker.onmessage=e=>this._onmessageFromWorker(e),this.worker.onerror=e=>this._onerrorFromWorker(e),this._postMessageToWorker("loadEncoder",{mimeType:this._mimeType,wasmPath:this._wasmPath})}_postMessageToWorker(e,t={}){switch(e){case"loadEncoder":let{mimeType:s,wasmPath:r}=t;this.worker.postMessage({command:e,mimeType:s,wasmPath:r});break;case"init":let{sampleRate:o,channelCount:a,bitsPerSecond:i}=t;this.worker.postMessage({command:e,sampleRate:o,channelCount:a,bitsPerSecond:i}),this.workerState="encoding",this.source.connect(this.processor),this.processor.connect(this.context.destination);let n=new global.Event("start");this.dispatchEvent(n);break;case"pushInputData":let{channelBuffers:c,length:h,duration:d}=t;this.worker.postMessage({command:e,channelBuffers:c,length:h,duration:d});break;case"getEncodedData":case"done":this.worker.postMessage({command:e});break;default:throw new Error("Internal Error: Incorrect postMessage requested.")}}_onmessageFromWorker(e){const{command:t,buffers:s}=e.data;let r;switch(t){case"readyToInit":const{sampleRate:e,channelCount:o}=this;this.workerState="readyToInit","recording"===this.state&&this._postMessageToWorker("init",{sampleRate:e,channelCount:o,bitsPerSecond:this.audioBitsPerSecond});break;case"encodedData":case"lastEncodedData":let a=new Blob(s,{type:this._mimeType});r=new global.Event("dataavailable"),r.data=a,this.dispatchEvent(r),"lastEncodedData"===t&&(r=new global.Event("stop"),this.dispatchEvent(r),this.workerState="closed")}}_onerrorFromWorker(e){this.source.disconnect(),this.processor.disconnect(),this.worker.terminate(),this.workerState="closed";let t=["FileName: "+e.filename,"LineNumber: "+e.lineno,"Message: "+e.message].join(" - "),s=new global.Event("error");s.name="UnknownError",s.message=t,this.dispatchEvent(s)}_enableAudioProcessCallback(e){let t=0;this.processor.onaudioprocess=s=>{const{inputBuffer:r,playbackTime:o}=s,{sampleRate:a,length:i,duration:n,numberOfChannels:c}=r,h=new Array(c);for(let e=0;e<c;e++)h[e]=r.getChannelData(e);const d={channelBuffers:h,length:i,duration:n};this._postMessageToWorker("pushInputData",d),t+=n,t>=e&&(this._postMessageToWorker("getEncodedData"),t=0)}}start(e=Number.MAX_SAFE_INTEGER){if("inactive"!==this.state)throw new Error("DOMException: INVALID_STATE_ERR, state must be inactive.");if(e<0)throw new TypeError("invalid arguments, timeslice should be 0 or higher.");e/=1e3,"closed"===this.workerState&&this._spawnWorker(),this.context=new AudioContext;let t=this.stream.getAudioTracks();if(!t[0])throw new Error("DOMException: UnkownError, media track not found.");if(this.channelCount=t[0].getSettings().channelCount||1,this.sampleRate=this.context.sampleRate,this.source=this.context.createMediaStreamSource(this.stream),this.processor=this.context.createScriptProcessor(4096,this.channelCount,this.channelCount),this._state="recording",this._enableAudioProcessCallback(e),"readyToInit"===this.workerState){const{sampleRate:e,channelCount:t}=this;this._postMessageToWorker("init",{sampleRate:e,channelCount:t,bitsPerSecond:this.audioBitsPerSecond})}}stop(){if("inactive"===this.state)throw new Error("DOMException: INVALID_STATE_ERR, state must NOT be inactive.");this.source.disconnect(),this.processor.disconnect(),this.context.close(),this._postMessageToWorker("done"),this._state="inactive"}pause(){if("inactive"===this.state)throw new Error("DOMException: INVALID_STATE_ERR, state must NOT be inactive.");this.source.disconnect(),this.processor.disconnect();let e=new global.Event("pause");this.dispatchEvent(e),this._state="paused"}resume(){if("inactive"===this.state)throw new Error("DOMException: INVALID_STATE_ERR, state must NOT be inactive.");this.source.connect(this.processor),this.processor.connect(this.context.destination);let e=new global.Event("resume");this.dispatchEvent(e),this._state="recording"}requestData(){if("inactive"===this.state)throw new Error("DOMException: INVALID_STATE_ERR, state must NOT be inactive.");this._postMessageToWorker("getEncodedData")}static isTypeSupported(e){if("string"==typeof e&&!e)return!0;try{var{type:t,subtype:s,codec:r}=OpusMediaRecorder._parseType(e)}catch(e){return!1}if("audio"!==t||"ogg"!==s&&"webm"!==s&&"wave"!==s&&"wav"!==s)return!1;switch(s){case"ogg":case"webm":if("opus"!==r&&r)return!1;break;case"wave":case"wav":if(r)return!1}return!0}static _parseType(e){try{const o=/^(\w+)\/(\w+)(;\s*codecs=(\w+))?$/;var[,t,s,,r]=e.match(o)}catch(t){return"string"!=typeof e||e?null:{type:"",subtype:"",codec:""}}return{type:t,subtype:s,codec:r}}}["start","stop","dataavailable","pause","resume","error"].forEach((e=>defineEventAttribute(OpusMediaRecorder.prototype,e))),browser&&"edge"===browser.name&&function(){var e=Worker.prototype.postMessage;Worker.prototype.postMessage=function(t,s=null){e.apply(this,[t])}}(),module.exports=OpusMediaRecorder;
//# sourceMappingURL=/sm/24161c34a8b86837f267f96b99cc9851ca5dfcdd0a2419a1a9ec20c71bc90a47.map